# Lab Instructions

## Lab Title
**`Network Device Commands with Netmiko`**

## Version
`v1.0`

## Estimated Time
`90-120 Minutes`

---

## Learning Objectives
By the end of this lab, you will be able to:
- Objective 1 ‚Äì Use Netmiko to establish an SSH session to a Cisco Catalyst 9K in the Cisco DevNet Always-On Sandbox.
- Objective 2 ‚Äì Collect credentials securely at runtime using input() and getpass.getpass().
- Objective 3 ‚Äì Execute basic IOS ‚Äúshow‚Äù commands and capture output to files.
- Objective 4 - Implement Python error handling (try/except) for connection and command failures.
- Objective 5 - Push simple configuration (loopback interfaces) from Python using iterable data structures.
- Objective 6 - Parse unstructured CLI output into structured data with ntc-templates (TextFSM).
- Objective 7 - Generate a simple, formatted report using f-strings (or Jinja2, optional).

These objectives build foundational skills for aspiring **network engineers** and **infrastructure specialists**.

---

## Tools & Technologies
You will use:
- Editor/Runtime
    - Visual Studio Code + Dev Containers extension
    - Docker Desktop (Windows/macOS; WSL2 enabled on Windows)
    - Git & GitHub Classroom repository
- Language & Libraries (preinstalled in container)
    - Python 3.x
    - netmiko (includes paramiko)
    - ntc-templates (+ TextFSM)
    - jinja2 (optional, for templated reports)
    - pprint (standard library)
- Target Device
    - Cisco DevNet Always-On Sandbox - Cisco Catalyst 8k or 9k
- Command Line
    - Bash (WSL, macOS, devcontainer)

---

## Prerequisites
Before starting, make sure you:
- Linux CLI basics: navigating directories, running Python scripts, viewing files.
- Git & GitHub fundamentals: clone, commit, push.
- Python fundamentals: functions, classes, exceptions, lists/dicts, file I/O, f-strings.
- Networking: IOS CLI familiarity, SSH, IP addressing/subnetting, basic interface config.

---

## Deliverables
Commit and push the following to your Classroom repo:
1) Source Code (in `src/`)
- `src/connect_basic.py`
    - Prompts for username (input) and hidden password (getpass), builds device dictionary, connects, runs one show command, saves raw output.
- `src/connect_with_errors.py`
    - Wraps connect/command in try/except and prints clear user-facing errors for bad login, timeout, or SSH issues.
- `src/add_loopbacks.py`
    - Iterates a list of dictionaries to add Loopback interfaces (name, IP/mask, description) and verifies with a show command.
- `src/parse_and_report.py`
    - Runs one or more show commands, parses with ntc-templates, pretty-prints structured data, and writes a short formatted report.

2) Data Artifacts (in `data/`)
- `data/raw/show_ip_int_brief.txt`
    - Raw output captured from `show ip interface brief`.
- `data/raw/verify_loopbacks.txt`
    - Raw output showing Loopbacks present after configuration.
- `data/reports/device_report.txt`
    - Human-readable summary with at least: hostname, model, uptime, count of up/up interfaces (or similarly meaningful fields).

3) Logs (in `logs/`)
- `logs/connect_basic.log`
    - Contains `LAB2_START` / `LAB2_END`, `DEVCONTAINER_OK`, `PKG_OK: netmiko`, `PKG_OK: ntc-templates`, `CONNECT_OK`, `CMD=show ip interface brief`, and `RAW_SAVED=....`
- `logs/connect_with_errors.log`
    - Shows at least one handled error line (e.g., `ERR=AuthenticationException`, `ERR=NetMikoTimeoutException`, or `ERR=SSHException`) and `EXIT_WITH_ERROR`.
- `logs/add_loopbacks.log`
    - One line per interface: `CFG_APPLIED name=... ip=... desc="..."`; plus verification lines and `VERIFY_OK ...`.
- `logs/parse_and_report.log`
    - `PARSE_OK platform=cisco command="show ip interface brief" items=<n>`, `PPRINT_OK`, and `REPORT_SAVED=...`.
- `logs/devcontainer_health.log` (auto-generated by the container)
    - Contains `LAB2_HEALTH_START/END`, `DNS_OK` (at least one), `NET_OK`, `PKG_OK name=netmiko`, `PKG_OK name=ntc_templates`, and a summary with `overall=True`.
- `logs/DEVCONTAINER_STATUS.txt` (auto-generated banner)
    - Shows a status with `Overall status: READY`.

> ‚ö†Ô∏è **Important:** Autograding will validate file presence, basic content checks, and selected parsed fields. Do not rename deliverables. Details on the point awards located in the Points section.

---

## Logging Snippet to Include
> **INSERT THIS CODE SNIPPET AT THE VERY TOP OF YOUR CODE RIGHT AFTER YOUR IMPORT STATEMENTS. IF A LOG MESSAGE IS REQUIRED AT ANY TIME IT WILL BE ANNOTAED IN THE INSTRUCTIONS.**

```python
from datetime import datetime, timezone

def now_iso():
    return datetime.now(timezone.utc).isoformat().replace("+00:00","Z")

def log(line, path):
    with open(path, "a", encoding="utf-8") as f:
        f.write(line.rstrip() + "\n")

# usage:
# log(f"LAB2_START ts={now_iso()}", "logs/connect_basic.log")
```

---

## Overview
In this lab you will: 
- Move from ‚Äúhello device‚Äù to ‚Äúuseful automation.‚Äù 
- Securely collect credentials, connect to a real Catalyst Switch in the DevNet sandbox, run show commands, and save the raw output.
- Add loopback interfaces programmatically and verify your changes. 
- Parse CLI output into structured data using ntc-templates and generate a short, human-readable report.   

üí° **Why this matters:** Modern networks cannot be managed manually at scale. Automation skills give you an edge as a job candidate and make you more effective in real-world environments. Raw CLI is for humans; structured data is for automation. NetDevOps workflows depend on three muscles you‚Äôll flex here:

1. Reproducible access (devcontainers + Netmiko),
2. Robustness (exception handling), and
3. Data shaping (TextFSM/ntc-templates) to feed reports, CI checks, and‚Äîlater‚ÄîAIOps pipelines.
Master these and you can scale beyond ‚Äúone-off‚Äù heroics to reliable, testable automation.

---

## Instructions

Follow these steps in order:

### Step 1 ‚Äì Clone the Repository
What you‚Äôre doing: Getting your own copy of the starter repo.
```bash
git clone <repo-url>
cd <repo-name>
```

Why this matters: Your work (scripts, logs, and outputs) must live in this repo so GitHub Classroom can grade it.

Done when
- You are in the new folder (`pwd` shows the repo path).
- `git status` shows you‚Äôre on the main/default branch with no local changes yet.

### Step 2 ‚Äì Open a Dev Container
What you‚Äôre doing: Opening a prebuilt development environment so everyone has the same tools and Python libraries.
1. Launch VS Code
2. When prompted, choose Reopen in Container (or Command Palette ‚Üí ‚ÄúDev Containers: Reopen in Container‚Äù).
3. Wait for the first-time build to finish (it downloads the image, installs requirements, runs a health check).

> NOTE: This can take a few minutes on first load

Quick health check in the terminal:
```bash
cat logs/DEVCONTAINER_STATUS.txt
# Expect: "Overall status: READY"
sed -n '1,120p' logs/devcontainer_health.log
# Look for: DNS_OK / NET_OK / PKG_OK lines
```

**If NOT READY:**

- Rebuild (Command Palette ‚Üí ‚ÄúDev Containers: Rebuild Container without Cache‚Äù).
- Verify you have internet access (campus/VPN firewalls can interfere).
- The health log tells you exactly which check failed.

**Done when**
- `logs/DEVCONTAINER_STATUS.txt` shows Overall status: **READY**.
- `logs/devcontainer_health.log` shows **DNS_OK**, **NET_OK**, and **PKG_OK** name=netmiko and **PKG_OK** name=ntc_templates.

### Step 3 ‚Äì Confirm Sandbox Target
What you‚Äôre doing: Identifying the exact device you‚Äôll connect to in Cisco DevNet (Always-On Catalyst/IOS-XE device).
1. Open the Cisco DevNet Always-On Sandbox page for the Catalyst device you‚Äôre using.
2. Note the host (hostname or IP), SSH port (usually 22), username, and password provided by DevNet.
3. From the terminal inside the container, sanity-check name resolution and reachability:
```bash
# Replace <host> with the sandbox host or IP shown on the DevNet page
ping -c 1 <host>        # DNS + basic reachability
curl -I https://www.google.com  # outbound internet sanity check (should be 200/301/302)
```
You will not hard-code any credentials in your scripts. You will ask for them at runtime.

4. You can also login via SSH to verify the you can reach the device from your host machine, authenticate, and access the `cli`.
```bash
ssh <username>@<hostname>
```

When prompted enter your provided password.

**Done When**
- You have the host, username, and password written down (from DevNet).
- `ping -c 1 <host>` succeeds (or you can at least reach the IP).
- You can SSH into the target network device.
- You‚Äôre ready to enter credentials when your scripts prompt you.

### Step 4 ‚Äì Explore the Library Surface Area
What you‚Äôre doing: Learning to read a Python library‚Äôs ‚Äúsurface area‚Äù (what classes and functions exist, and what parameters they take).

1. Start a Python shell: python
2. Follow the README section Reviewing the Docs, Methods, and Arguments to:
    - Inspect what‚Äôs inside the Netmiko package.
    - View how the connection class is documented (purpose, parameters).
    - Identify the device type string that matches a Cisco IOS/IOS-XE device.

> Tip: This is about discovery. You‚Äôre training yourself to explore any Python library you‚Äôll use in the future.

**Done when**

- You can name the connection class you‚Äôll use.
- You can state the correct device type string for a Cisco IOS/IOS-XE device.
- You know which method sends a command to the device.

### Step 5 ‚Äì Establish Connection & Run a Show Command
What you‚Äôre doing: Building your first script that connects and runs a single read-only command.

Create src/connect_basic.py (no code here in the instructions; see README for concepts you‚Äôll use).

Your script must:

Ask for a username and a hidden password at runtime.

Build a device dictionary with type, host, username, and password.

Open a connection to the sandbox device.

Run a simple command such as show ip interface brief.

Print the output to the terminal.

Save the raw output to data/raw/show_ip_int_brief.txt.

Write natural, one-line log events to logs/connect_basic.log (see Deliverables for the event names).

Run it:
```bash
python src/connect_basic.py
```

**Done When**
- You see the command output in the terminal
- `data/raw/show_ip_int_brief.txt` exists and is non-empty.
- `logs/connect_basic.log` contains lines like:
    - `CONNECT_OK`
    - `CMD=show ip interface brief`
    - `RAW_SAVED=data/raw/show_ip_int_brief.txt BYTES=<n>`

### Step 6 ‚Äì Add Error Handling
What you‚Äôre doing: Making your script resilient and friendly when things go wrong.
1. Create src/connect_with_errors.py.
2. Wrap your connection and command steps in try/except blocks that:
    - Catch a bad password scenario.
    - Catch a timeout / unreachable host scenario.
    - Catch a general SSH failure scenario.
3. Print a short, clear message to the user (no stack traces).
4. Write meaningful log events to logs/connect_with_errors.log including an exit with error marker.

**Test it by simulating errors:**
```bash
# Example tests (do not paste secrets or stack traces in logs)
python src/connect_with_errors.py   # then intentionally mistype the password
python src/connect_with_errors.py   # or temporarily change the host to a bogus value
```

**Done When**
- Your script shows a friendly error message for each case.
- logs/connect_with_errors.log includes at least one of:
    - ERR=AuthenticationException
    - ERR=NetMikoTimeoutException
    - ERR=SSHException
- The log ends with EXIT_WITH_ERROR.
### Step 7 ‚Äì Automate Loopback Configuration
What you‚Äôre doing: Applying a small, repeatable change to the device using structured data.
1. Create `src/add_loopbacks.py`.
2. Prepare a short list of items (each item should include a loopback name, an IP with mask, and a description).
3. Enter device configuration mode and add each loopback from your list.
4. After pushing changes, run a show command that proves the loopbacks exist.
5. Save the verification output to `data/raw/verify_loopbacks.txt`.
6. Log one line per interface configured and a verification line in `logs/add_loopbacks`.log.

**Notes**
- Use a host-only address space (for example, a `/32` mask) for loopbacks in labs.
- Always verify what you changed‚Äîthis is a core automation habit.

**Done when**
- Loopbacks appear in the device output.
- `data/raw/verify_loopbacks.txt` exists and is non-empty.
- `logs/add_loopbacks.log` shows:
    - one `CFG_APPLIED ...` line per loopback, and
    - a verification line like `VERIFY_OK ...`.

### Step 8 ‚Äì Parse CLI Output with ntc-templates
What you‚Äôre doing: Turning messy device text into structured data your code can understand.
1. Create src/parse_and_report.py.
2. Run one or more show commands (for example, interfaces and version).
3. Use ntc-templates to parse the output into a structured form.
4. Print a clear preview of the structured data (for human review).
5. Log parsing success and item counts in logs/parse_and_report.log.

> Important: Parsing relies on exact command names. If the template expects ‚Äúshow ip interface brief‚Äù, spelling it differently will return nothing. See the README section TextFSM & NTC Templates.

**Done when**
- Your terminal shows structured data (not raw device text).
- `logs/parse_and_report.log` contains something like:
    - `PARSE_OK platform=cisco command="show ip interface brief" items=<n>`
    - `PPRINT_OK`

### Step 9 ‚Äì Generate a Short Report
What you‚Äôre doing: Producing a readable summary that could be shared or checked into docs.
1. In `src/parse_and_report.py` (same script), create a short report that includes a few key facts, such as:
    - device name,
    - device model,
    - uptime,
    - number of interfaces that are up/up.
2. Save the report to `data/reports/device_report.txt`.
3. Add a log line showing where you saved the report and what fields it contains.

**Done when**
- `data/reports/device_report.txt` exists and contains the key fields you chose.
- `logs/parse_and_report.log` includes:
    - `REPORT_SAVED=data/reports/device_report.txt FIELDS=...`

### Step 10 ‚Äì Commit, Push, Verify
What you‚Äôre doing: Submitting your work and verifying that the autograder can see everything.
```bash
git add .
git commit -m "Lab 2 complete: connect, error handling, loopbacks, parsing, report"
git push
```
1. Open your GitHub Classroom repository page and check the Actions tab.
2. Wait for the autograder to run.
3. If it fails, click into the logs‚Äîeach check maps to a specific file or log line from the Deliverables section.

**Done when**
- GitHub Actions shows a green check for this lab.
- Your repo contains:
    - All four scripts in src/,
    - Raw outputs in data/raw/,
    - The report in data/reports/,
    - All required log files in logs/,
    - Devcontainer health files showing READY.

### Guardrails (read once, save points later)
- Never hard-code a password. Use a hidden prompt at runtime.
- Keep file names and paths exactly as shown; the autograder looks for these.
- Logs must be plain text with one event per line and no secrets.

> If you get stuck, re-read the matching theory in the README (those sections were written to answer the ‚Äúwhy‚Äù behind each step).

## :wrench: Troubleshooting & Common Pitfalls
**1. Dev Container Didn‚Äôt Install Dependencies**
- **Symptom:** `ModuleNotFoundError: No module named 'netmiko'` (or `ntc_templates`) when running code.
- **Fix:** Make sure you opened the repo in the devcontainer. Run `pip list` inside the container to confirm the libraries are there. If missing, reinstall with:

```bash

pip install -r requirements.txt

```

**2. Wrong Hostname or IP Address**
- **Symptom:** Connection times out or immediately fails.
- **Fix:** Double-check the Cisco DevNet Always-On sandbox page for the device‚Äôs IP/hostname. If using hostname, make sure your container can resolve it (`ping <hostname>`). If not, use the raw IP.

**3. Incorrect Device Type**
- **Symptom:** Connection starts but fails during login, or you see errors like `Authentication to device failed`.
- **Fix:** Netmiko requires the exact `device_type` string (e.g., `"cisco_ios"`, `"cisco_xe"`, etc.). Run `dir(netmiko)` in Python to confirm available device types. Use the one matching the sandbox device.

**4. Hard-Coded Credentials**
- **Symptom:** You push your script and your username/password are visible in GitHub history.
- **Fix:** Always use `input()` and `getpass.getpass()` for credentials. If you accidentally pushed secrets, remove them, then rotate/change the sandbox credentials.

**5. Password Still Shows When Typed**
- **Symptom:** Password characters appear in the terminal.
- **Fix:** Make sure you‚Äôre using `getpass.getpass()` not `input()`. `input()` always echoes text to the terminal.

**6. Unstructured or Messy Output**
- **Symptom:** `print(output)` from a show command looks like jumbled text.
- **Fix:** This is expected raw CLI. Use `ntc-templates` + `parse_output()` to convert it into structured data. Pretty-print it with `pprint()` for readability.

**7. `IndexError` or Empty Parsed Data**
- **Symptom:** Running `parse_output()` returns an empty list or error.
- **Fix:** This happens if your `platform` or `command` doesn‚Äôt exactly match what `ntc-templates` expects.
    - Example: `"show ip interface brief"` is valid, but `"show ip int brief"` will not parse.
    - Check the [ntc-templates GitHub repo](https://github.com/networktocode/ntc-templates) for supported command strings.

**8. Connection Drops or Times Out**
- **Symptom:** `EOFError` or `SSH session not active`.
- **Fix:** Make sure you‚Äôre storing the connection in a variable (e.g., `device_connection = ConnectHandler(**device)`). Don‚Äôt let the connection object go out of scope before sending commands.

9. File Writing Errors
- Symptom: Python throws `FileNotFoundError` or doesn‚Äôt save output.
- Fix: Ensure you‚Äôre writing files to the correct relative path (`data/raw/` or `data/reports/`).
```bash

with open("data/raw/show_ip_int_brief.txt", "w") as f:
    f.write(output)

```

10. GitHub Autograder Fails
- Symptom: Points deducted even though your script works locally.
- Fix:
    - Verify file names and paths match the lab instructions exactly (`connect_basic.py` ‚â† `ConnectBasic.py`).
    - Ensure your script runs without user input blocking (except for creds).
    - Make sure you committed and pushed all files, not just saved them locally.

## :bulb:Pro Tips
**Keep Connections Clean**
- Use a `with` statement for Netmiko connections so they close automatically:
```python
from netmiko import ConnectHandler
with ConnectHandler(**device) as conn:
    output = conn.send_command("show version")
```

**Always Sanity-Check Parsed Data**
- After using `parse_output()`, quickly check the data structure before building logic around it:
```python
from pprint import pprint
pprint(parsed_data)
```

**Leverage the `requirements.txt` File**
- If you try out a new library (like `jinja2`), add it with:
```bash
pip freeze | grep jinja2 >> requirements.txt
```

**Structure Your Scripts Early**
- Use functions even in small scripts. For example:
```python
def get_device_connection(device):
    return ConnectHandler(**device)
```

**Use Logging Instead of Print**
- For debugging, consider Python‚Äôs built-in `logging` library instead of `print()`. You can set log levels (info, warning, error) and later redirect logs to a file.
**Validate Configurations**
- When adding loopback interfaces, always follow with a ‚Äúshow‚Äù verification step. This mirrors how professional engineers build idempotent automation (safe to run multiple times without breaking things).
**Think in Data Structures, Not Strings**
- Avoid writing fragile string-parsing hacks. Always aim to produce or consume dictionaries/lists that can be validated, extended, and reused.
**Stretch Goal: Reporting Upgrade**
- Instead of a plain-text report, generate a Markdown file (`.md`) that could drop into a GitHub wiki or project documentation. Markdown plays nicely with version control and looks clean.

## Grading and Points Breakdown

> **NOTE: ZERO CREDIT CONDITIONS**
- 0 PTS FOR THE LAB IF:
    - Any log prints a full password, token, or private key.
    - Files in .github/workflows/ are modified.
    - Required file names/paths changed to dodge checks.
- -5 pts hygiene if logs show obviously fabricated counts (e.g. items=9999) without matching files.

| Step               | Requirement                                               | Points |
| ------------------ | --------------------------------------------------------- | ------ |
| 1. Setup           | Container opens and packages installed                    | 5      |
| 2. Explore library | Show methods or details from Netmiko                      | 5      |
| 3. Secure login    | Use input for username and hidden password                | 4      |
| 3. Secure login    | Device dictionary has type, host, username, password      | 4      |
| 4. Connect         | Successful connection made to device                      | 5      |
| 5. Show command    | Run a show command and save raw output to file            | 5      |
| 6. Error handling  | Script shows clear error message for bad login or timeout | 8      |
| 7. Loopback config | Add loopback from list of dictionaries                    | 8      |
| 7. Loopback config | Show command verifies loopbacks and saves to file         | 6      |
| 8. Parse output    | Use templates to parse show command into structured data  | 7      |
| 8. Parse output    | Print structured data in clear format                     | 3      |
| 9. Report          | Create and save formatted report with key device details  | 10     |
| All steps          | Logs created with start and end, no secrets shown         | 5      |
| **Total**          |                                                           | **75** |




## Submission Checklist
:green_checkmark: Repo Cloned
:green_checkmark: Dev Container Opened
:green_checkmark: All four scripts exist in src/ and run inside the devcontainer without edits to grader files.
:green_checkmark: Raw outputs saved to data/raw/ and are non-empty.
:green_checkmark: Report saved to data/reports/device_report.txt with required fields.
:green_checkmark: All four lab logs exist in logs/ with the required event lines; no secrets appear in any log.
:green_checkmark: Devcontainer health files exist: logs/devcontainer_health.log and logs/DEVCONTAINER_STATUS.txt show READY.
:green_checkmark: Pushed to GitHub; Actions autograder passes.    