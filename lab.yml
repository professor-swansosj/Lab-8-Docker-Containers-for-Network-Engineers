# ==========================================
# Course: Software Defined Networking
# Module: Docker Containers for Network Engineers
# Purpose: Hands on activity to build and run Docker containers
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 8 — Docker Containers for Network Engineers"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 8
time_estimate: "120–150 minutes"

#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:

  - title: "What is a Docker Container?"
    content: |
      A Docker container is a lightweight, portable, and self-sufficient unit that encapsulates an application and all its dependencies, libraries, and configuration files. Containers are built from Docker images, which serve as the blueprint for the container's filesystem and environment.

      Key characteristics of Docker containers include:
      - **Isolation**: Containers run in their own isolated environments, ensuring that applications do not interfere with each other.
      - **Portability**: Containers can run consistently across different environments, such as development, testing, and production.
      - **Efficiency**: Containers share the host system's kernel, making them more lightweight and faster to start than traditional virtual machines.

      In our last lab, we explored the basics of Docker and containerization. In this lab, we will dive deeper into building and running Docker containers for network engineering tasks. Below is a simple example of how to use Docker to run a container.


    code_block:
      language: bash
      code: |
        docker run hello-world

    code_notes: >
      The `docker run hello-world` command pulls the `hello-world` image from Docker Hub (if not already present locally) and runs it in a new container. The output confirms that Docker is installed and functioning correctly on your system.

      In this lab, we will build upon this foundation by creating a custom Docker image for a FastAPI application that interacts with network devices using Ansible. We will cover the following objectives:

  - title: "Containers vs Virtual Machines"
    content: |
      While both containers and virtual machines (VMs) provide isolated environments for running applications, they do so in fundamentally different ways.

      **Virtual Machines**:
      - VMs run a full operating system (OS) on top of a hypervisor, which abstracts the underlying hardware.
      - Each VM includes its own OS kernel, libraries, and applications, leading to larger resource consumption.
      - VMs are typically slower to start and require more disk space.

      **Containers**:
      - Containers share the host OS kernel and isolate applications at the process level.
      - They package only the application and its dependencies, making them more lightweight and efficient.
      - Containers start quickly and use less disk space compared to VMs.

  - title: "Containers in Network Engineering"
    content: |
      Containers have become increasingly popular in network engineering for several reasons:
      - **Automation**: Containers can be easily integrated into CI/CD pipelines, enabling automated testing and deployment of network applications.
      - **Scalability**: Containers can be quickly scaled up or down to meet changing network demands.
      - **Consistency**: Containers ensure that applications run consistently across different environments, reducing the "it works on my machine" problem.
      - **Microservices**: Containers facilitate the development and deployment of microservices architectures, allowing network functions to be broken down into smaller, manageable components.

      In this lab, we will explore how to leverage Docker containers to build a FastAPI application that interacts with network devices using Ansible.

  - title: "The Dockerfile"
    content: |
      A Dockerfile is a text file that contains a series of instructions for building a Docker image. It defines the base image, application code, dependencies, environment variables, and commands to run when the container starts.

      Here is a simple example of a Dockerfile for a FastAPI application:

    code_block:
      language: dockerfile
      code: |
        # Use the official Python image as a base
        FROM python:3.11

        # Set the working directory
        WORKDIR /app

        # Copy the application code
        COPY . .

        # Install dependencies
        RUN pip install -r requirements.txt

        # Expose the application port
        EXPOSE 8000

        # Start the FastAPI application
        CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

    code_notes: >
      In this Dockerfile:
      - We start with the official Python 3.11 image as our base.
      - We set the working directory to `/app` inside the container.
      - We copy the application code from the host to the container.
      - We install the required Python packages listed in `requirements.txt`.
      - We expose port 8000, which is the default port for FastAPI applications.
      - Finally, we define the command to start the FastAPI application using Uvicorn.

      In this lab, we will create a more complex Dockerfile that includes Ansible and other dependencies needed for our network automation tasks.

  - title: "Understanding Containers and Images"
    content: |
      In summary, Docker containers are lightweight, portable units that encapsulate applications and their dependencies. They differ from virtual machines in their architecture and resource efficiency. Containers are widely used in network engineering for automation, scalability, and consistency.

      The Dockerfile is a crucial component in the containerization process, as it defines how to build a Docker image. By following best practices in writing Dockerfiles, we can create efficient and maintainable images for our applications.

      In the following sections of this lab, we will apply these concepts by building and running a Docker container for a FastAPI application that interacts with network devices using Ansible.

  - title: "Managing your Containers and Images"
    content: |
      Once you have built and run your Docker containers, it's important to know how to manage them effectively. Here are some common commands for managing Docker containers and images:

      **Managing Containers**:
      - `docker ps`: List all running containers.
      - `docker ps -a`: List all containers (running and stopped).
      - `docker stop <container_id>`: Stop a running container.
      - `docker start <container_id>`: Start a stopped container.
      - `docker restart <container_id>`: Restart a container.
      - `docker rm <container_id>`: Remove a stopped container.
      - `docker logs <container_id>`: View the logs of a container.

      **Managing Images**:
      - `docker images`: List all Docker images on your system.
      - `docker rmi <image_id>`: Remove a Docker image.
      - `docker tag <image_id> <new_image_name>:<tag>`: Tag an image with a new name and tag.
      - `docker pull <image_name>`: Pull an image from Docker Hub or another registry.
      - `docker push <image_name>`: Push an image to Docker Hub or another registry.

      By mastering these commands, you can efficiently manage your Docker containers and images, ensuring that your development and deployment processes run smoothly.

#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================
# LAB 8 — DOCKER CONTAINERS FOR NETWORK ENGINEERS
# Software Defined Networking • Florida State College at Jacksonville
# Worth 75 points

# OBJECTIVES
objectives:
  - "Author a Dockerfile to containerize a FastAPI webhook service."
  - "Add a new FastAPI path that triggers an Ansible backup playbook."
  - "Package required dependencies (FastAPI, Uvicorn, requests, Netmiko, ncclient, Ansible, collections)."
  - "Use environment variables and volumes for credentials and persistent artifacts."
  - "Build, run, test, and log deterministic markers for autograding."

# PREREQUISITES
python_version: "3.11"
accounts: ["GitHub", "Cisco DevNet"]
devices:
  - "Local Docker Engine"
  - "Cisco DevNet Always-On Catalyst 8k/9k (for backup target)"

prereq:
  - "FastAPI app from Lab 6 (webhooks working)."
  - "Basic Docker commands: build, run, logs, stop, rm."
  - "Ansible basics (inventory, playbooks, collections)."
  - "GitHub Classroom workflow (clone, commit, push, PR)."

# OVERVIEW
overview: >
  You will containerize your FastAPI webhook service from Lab 6 and extend it with a new endpoint that,
  when called, runs an Ansible playbook to back up device configurations from the Catalyst 8k and 9k
  sandboxes. You will write a production-minded Dockerfile, install Python and Ansible dependencies,
  prepare an inventory and playbook in the image, and expose port 8000. Runtime environment variables
  provide credentials; a bind-mounted volume preserves backups and logs. You will build, run, and test
  the container, saving artifacts and log markers for autograding.

# SETUP
before_you_begin: >
  Verify Docker is installed and the Docker daemon is running (`docker version` works). Ensure you can
  write to `data/` and `logs/`. Have the IP/hostnames for the Cat8k and Cat9k sandboxes ready.

# RESOURCES
resources:
  - { title: "Dockerfile reference", url: "https://docs.docker.com/engine/reference/builder/" }
  - { title: "FastAPI", url: "https://fastapi.tiangolo.com/" }
  - { title: "Uvicorn", url: "https://www.uvicorn.org/" }
  - { title: "Ansible docs", url: "https://docs.ansible.com/" }
  - { title: "cisco.ios collection", url: "https://docs.ansible.com/ansible/latest/collections/cisco/ios/" }

# DELIVERABLES
deliverables:
  - "`Dockerfile` that builds a runnable image for the FastAPI app."
  - "`src/app.py` FastAPI webhook with a new POST path `/backup/ansible`."
  - "Ansible artifacts inside repo: `playbooks/backup.yml`, `inventories/inventory.yml`, `requirements.yml`."
  - "Build and run transcripts saved to `data/docker_build.txt` and `data/docker_run.txt`."
  - "Backups saved under `data/backups/` (e.g., `cat8k_running_config.txt`, `cat9k_running_config.txt`)."
  - "`logs/lab8.log` with required markers."
  - "Pull request open to `main` with all artifacts committed."

# STEPS
steps:
  - title: "Clone the Repository"
    goal: "Get your starter locally."
    actions: |
      Clone your GitHub Classroom repo and `cd` into it. Create `src/`, `playbooks/`, `inventories/`,
      `data/backups/`, and `logs/` if missing.
      Initialize the lab log: `echo 'LAB8_START' >> logs/lab8.log`
    done_when: |
      - Folders exist and `LAB8_START` appears in `logs/lab8.log`.
    log_marker: "LAB8_START"

  - title: "Dev Container Check (Optional)"
    goal: "Confirm Python app still runs locally."
    actions: |
      If using dev containers, reopen now and verify `python -c "import fastapi, uvicorn; print('OK')"` prints OK.
      Append `[STEP 2] Dev Container Started` to `logs/lab8.log` if you used it.
    done_when: |
      - Local run sanity-checked OR dev container confirmed.
    log_marker: "[STEP 2] Dev Container Started"

  - title: "Extend FastAPI App"
    goal: "Add `/backup/ansible` POST endpoint."
    actions: |
      In `src/app.py` (from Lab 6), add a new POST handler:
        - Validates token (same `X-Webhook-Token` approach).
        - Invokes an Ansible playbook (subprocess) to back up Cat8k and Cat9k running-configs.
        - Writes backups to `data/backups/` and returns a JSON summary (hostnames + file paths).
        - Logs `BACKUP_CALLED` and `BACKUP_FILES_SAVED`.
      Keep existing endpoints from Lab 6 working.
    done_when: |
      - New endpoint implemented without breaking other paths.
    log_marker: "WEBHOOKS_OK"

  - title: "Author the Ansible Playbook & Inventory"
    goal: "Create portable IaC inside the container."
    actions: |
      Create:
        - `requirements.yml` (include `cisco.ios` and `ansible.netcommon`).
        - `inventories/inventory.yml` with hosts `cat8k` and `cat9k` (use env vars for creds; no secrets in repo).
        - `playbooks/backup.yml` that:
            * Runs against group `iosxe`
            * Uses `cisco.ios.ios_command` (e.g., `show running-config`) or `cisco.ios.ios_config` with `backup: true`
            * Registers output and writes files to `/app/data/backups/` (container path)
      Log `ANSIBLE_ASSETS_OK`.
    done_when: |
      - Inventory, requirements, and playbook validate (`ansible-playbook --syntax-check playbooks/backup.yml`).
    log_marker: "ANSIBLE_ASSETS_OK"

  - title: "Write the Dockerfile"
    goal: "Containerize app + Ansible cleanly."
    actions: |
      Create `Dockerfile` that:
        - Uses a slim Python 3.11 base.
        - Installs system deps needed by Ansible/SSH (e.g., `openssh-client`, `sshpass`, `git`).
        - `pip install` Python deps (fastapi, uvicorn, requests, netmiko, ncclient, xmltodict, ansible, ansible-pylibssh).
        - Copies `src/`, `playbooks/`, `inventories/`, `requirements.yml`, and `logs/` scaffold into `/app`.
        - Runs `ansible-galaxy collection install -r /app/requirements.yml` at build time.
        - Creates non-root user; sets `WORKDIR /app`.
        - Exposes `8000` and adds a `HEALTHCHECK` hitting `/health` endpoint.
        - `CMD ["uvicorn", "src.app:app", "--host", "0.0.0.0", "--port", "8000"]`
      Log `DOCKERFILE_OK`.
    done_when: |
      - Dockerfile passes `hadolint` (if available) and looks production-minded.
    log_marker: "DOCKERFILE_OK"

  - title: "Build the Image"
    goal: "Produce a tagged image."
    actions: |
      Run: `docker build -t sdn-fastapi-backup:lab8 . | tee data/docker_build.txt`
      On success, append `BUILD_OK` to `logs/lab8.log`.
    done_when: |
      - Image `sdn-fastapi-backup:lab8` exists; build transcript saved.
    log_marker: "BUILD_OK"

  - title: "Run the Container"
    goal: "Start service with env + volume."
    actions: |
      Run (example):
        docker run -d --name sdn-lab8 \
          -p 8000:8000 \
          -e WEBHOOK_TOKEN=<your_token> \
          -e ANSIBLE_USER=<sandbox_user> \
          -e ANSIBLE_PASSWORD=<sandbox_pass> \
          -e CAT8K_HOST=<ip_or_fqdn> \
          -e CAT9K_HOST=<ip_or_fqdn> \
          -v "$PWD/data:/app/data" \
          sdn-fastapi-backup:lab8 | tee data/docker_run.txt
      Append `RUN_OK` to `logs/lab8.log`.
    done_when: |
      - Container is running and mapped to localhost:8000.
    log_marker: "RUN_OK"

  - title: "Health & Endpoint Tests"
    goal: "Verify service is alive and endpoints respond."
    actions: |
      Hit health (if implemented) and a simple endpoint (e.g., `/joke`) with the token:
        curl -s -X POST http://localhost:8000/joke -H "X-Webhook-Token: <your_token>"
      Save brief test notes to `data/test_notes.txt`. Append `HEALTH_OK` to log.
    done_when: |
      - At least one non-backup endpoint returns 200.
    log_marker: "HEALTH_OK"

  - title: "Trigger Ansible Backup"
    goal: "Execute the new endpoint and persist artifacts."
    actions: |
      Call:
        curl -s -X POST http://localhost:8000/backup/ansible \
          -H "X-Webhook-Token: <your_token>" \
          -H "Content-Type: application/json" \
          -d '{"targets":["cat8k","cat9k"]}'
      Ensure output files appear in `data/backups/` and JSON response lists file paths.
      Append `BACKUP_OK` and `BACKUP_FILES_SAVED` to the log.
    done_when: |
      - `data/backups/` contains both device backups with non-empty content.
    log_marker: "BACKUP_OK, BACKUP_FILES_SAVED"

  - title: "Finalize & Submit"
    goal: "Stop, clean, and open PR."
    actions: |
      Append `LAB8_END` to `logs/lab8.log`. Optionally stop/remove the container:
        docker stop sdn-lab8 && docker rm sdn-lab8
      Commit and push all artifacts; open a PR targeting `main`.
    done_when: |
      - PR open; all required files present.
    log_marker: "LAB8_END"

# FAQ + TROUBLESHOOTING
faq:
  - q: "Backups didn't appear under data/backups/"
    a: "Check your `-v $PWD/data:/app/data` bind mount and ensure the playbook writes to `/app/data/backups/`."
  - q: "401 Unauthorized on POST"
    a: "Send the header `X-Webhook-Token: <token>`; ensure the container has `WEBHOOK_TOKEN` set."
  - q: "Ansible authentication fails"
    a: "Provide `ANSIBLE_USER` / `ANSIBLE_PASSWORD` env vars and correct `CAT8K_HOST` / `CAT9K_HOST`."
  - q: "ncclient/Netmiko missing"
    a: "Confirm they're installed in the image; rebuild after editing the Dockerfile."

tips:
  - title: "Keep secrets out of Git"
    symptom: "Credentials leaked in repo."
    fix: "Use env vars or a `.env` loaded by your run script; never commit secrets."
  - title: "Repeatable images"
    symptom: "Builds differ across machines."
    fix: "Pin Python base image tag and key pip package versions where possible."
  - title: "Faster builds"
    symptom: "Slow rebuilds after code edits."
    fix: "Copy dependency files earlier in the Dockerfile to leverage layer caching."

# GRADING
grading:
  total_points: 75
  rows:
    - { step: "FastAPI", requirement: "Existing endpoints retained; new `/backup/ansible` implemented (`WEBHOOKS_OK`)", points: 10 }
    - { step: "Ansible", requirement: "Inventory + playbook + requirements set up (`ANSIBLE_ASSETS_OK`)", points: 10 }
    - { step: "Dockerfile", requirement: "Clean, production-minded Dockerfile (`DOCKERFILE_OK`)", points: 5 }
    - { step: "Build", requirement: "Image builds; transcript saved (`BUILD_OK` + `data/docker_build.txt`)", points: 10 }
    - { step: "Run", requirement: "Container runs with env + volume; transcript saved (`RUN_OK` + `data/docker_run.txt`)", points: 5 }
    - { step: "Health", requirement: "Service reachable; non-backup endpoint works (`HEALTH_OK`)", points: 5 }
    - { step: "Backup", requirement: "Backup endpoint succeeds; files present (`BACKUP_OK`, `BACKUP_FILES_SAVED`)", points: 15 }
    - { step: "Submission", requirement: "PR open; log hygiene (`LAB8_START`/`LAB8_END` present)", points: 15 }

# AUTOGRADING
autograder:
  log_path: "logs/lab8.log"
  required_markers:
    - "LAB8_START"
    - "[STEP 2] Dev Container Started"
    - "WEBHOOKS_OK"
    - "ANSIBLE_ASSETS_OK"
    - "DOCKERFILE_OK"
    - "BUILD_OK"
    - "RUN_OK"
    - "HEALTH_OK"
    - "BACKUP_OK"
    - "BACKUP_FILES_SAVED"
    - "LAB8_END"

# SUBMISSION CHECKLIST
submission_checklist:
  - "`Dockerfile` builds `sdn-fastapi-backup:lab8` successfully."
  - "Container runs exposing :8000 with token + device env vars and a `data/` volume."
  - "`/backup/ansible` returns 200 and creates backups under `data/backups/`."
  - "Transcripts saved to `data/docker_build.txt` and `data/docker_run.txt`."
  - "`logs/lab8.log` includes all required markers."
  - "Pull request open to `main` before deadline."

license: "© 2025 Sheldon Swanson — Classroom use."